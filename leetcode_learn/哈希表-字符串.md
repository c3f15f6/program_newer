---
title: 哈希表-字符串
tags: [leetcode, 代码随想录,编程]
categories:
- 编程
hide: false
---

# 哈希表

**感谢[代码随想录](https://programmercarl.com/)**

## 快乐数

[快乐数](https://programmercarl.com/0202.快乐数.html#思路)

查找数字是否重复出现，使用哈希表存储

```c++
#include <set>
set<int> s;
s.insert(a); // 插入数据
if(s.find(a)!= s.end()){
    // 查找数据是否在s中
    //如果出现 != s.end(), 没出现 == s.end()
}
```

## 两数之和

[两数之和](https://programmercarl.com/0001.两数之和.html#算法公开课)

1. map存放在之前的数据，也是当前查询中匹配的数据
2. map中key对应数值，value对应索引
3. unordered_map中使用Hash存储， map中使用红黑树存储

## 三数之和

[三数之和](https://programmercarl.com/0015.三数之和.html#思路)

1. 使用三个指针，查找指针对应的数据之和是否为0

2. 指针去重，结果中不能包含统一的数据，所以在取得结果后再去重，而不是先去重再计算结果

 ```c++
   if(i> 0 && nums[i]== nums[i-1]){
   	continue;//对已有结果去重
   }
 ```

3. vector<int>**{**1， 2，3**}**，使用{}作为临时vector
4. `for( ; ; ) ` 中第一个式子只对第一次循环有效，循环中赋初值需放在循环内

## 两次hash统计

[独一无二出现次数](https://programmercarl.com/1207.独一无二的出现次数.html#思路)

出现次数只出现一次，返回`true`

1. 先统计`数字`出现次数

   > 数字中如果有负数，计算次数时， 数组索引需增加最小值

2. 统计 `出现次数`的次数

   > 出现次数为0 的次数，直接跳过

# 字符串

## 反转字符串

[反转字符串2](https://programmercarl.com/0541.反转字符串II.html#思路)

1. 对于有规律的计数时，使用i = i+ num， 
2. reverse(begin()+i， begin+k)，反转范围为[i,k）

## 花式反转

[先反转整体，再反转局部](https://programmercarl.com/0151.翻转字符串里的单词.html#思路)

1. 去除空格时，sum值代表字符串的长度
2. 当s 遍历到结尾时，也是一个反转条件

## KMP算法

获得next数组

1. 初始化为0
2. 如果s[i] 与s[j] 相同，最长的 j +1；
3. 否则与next[j-1]的字串进行比较；

比较

1. 如果s[i] 与t[j] 相同， j++ ，比较下一位
2. 否则返回到最长的公共子串的下一位， 即next[j-1]比较

> next初值赋值为1 时，相当于next 向右移动了一位，此时不相同时，取next[j]即可

## 重复子串

[重复子串](https://programmercarl.com/0459.重复的子字符串.html)

![图二](%E5%93%88%E5%B8%8C%E8%A1%A8-%E5%AD%97%E7%AC%A6%E4%B8%B2/20220728104931.png)

**结论： 如果s是由重复序列组成，那么s+s中一定具有s**





















