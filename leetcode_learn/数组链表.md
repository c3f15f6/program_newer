---
title: 数组-链表
date: 2024-09-24 16:33:22
tags: [leetcode, 代码随想录,编程]
categories:
- 编程
hide: false
---

**感谢[代码随想录](https://programmercarl.com/)**

# 数组

## 滑动窗口

[求出长度最小的子数组]: https://leetcode.cn/problems/minimum-size-subarray-sum/

不断调整起始位置和终止位置，处理一块区间内的数据。

在本题中实现滑动窗口，主要确定如下三点：

- **窗口内是什么？**
- **如何移动窗口的起始位置？**
- **如何移动窗口的结束位置？**

窗口就是 满足其和 ≥ s 的长度最小的 连续 子数组。

窗口的起始位置如何移动：**如果当前窗口的值大于等于s了，窗口就要向前移动了（也就是该缩小了）。**确定好移动的情况，并处理需要优先移动窗口还是先处理窗口中的数据。

<img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20210312160441942.png" alt="滑动窗口" style="zoom:67%;" />

窗口的结束位置如何移动：窗口的结束位置就是遍历数组的指针，也就是for循环里的索引。

## 螺旋数组

**确定边界处理的不变量，确保每个子问题的结构都是相同的**

然后按照不变量写出每次循环的次数

<img src="%E6%95%B0%E7%BB%84%E9%93%BE%E8%A1%A8/20220922102236.png" alt="循环数组" style="zoom:50%;" />

1. 尽可能保证每次循环中的 量 是不变的
2. 进入下一次循环时， 控制这个量发生改变
3. 尽可能减少控制

# 链表

## 删除链表

[删除倒数第n值](https://programmercarl.com/0019.删除链表的倒数第N个节点.html#算法公开课)

删除列表时，最好增加dummy_head节点，删掉头节点更方便

> 1. fast 先移动 n+1 个
> 2. 然后slow, fast 同时移动，fast始终比slow 快N + 1
> 3. 当fast 到达末尾时，slow 与末尾的距离是N

![增加dummy-head](%E6%95%B0%E7%BB%84%E9%93%BE%E8%A1%A8/19.%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%ACN%E4%B8%AA%E8%8A%82%E7%82%B9.png)

## 链表相交

[返回相交链表节点](https://programmercarl.com/面试题02.07.链表相交.html#思路)

![img](%E6%95%B0%E7%BB%84%E9%93%BE%E8%A1%A8/20211219221723.png)

1. 求A，B的长度$l_A,l_B$

2. 为方便起见，将A始终未较长链表，否则将A，B交换 

3. 根据$l_A,l_B$ 的差值，将长端链表对齐

   > 使用方法为： 长端先走一些位置

4. 依次比较

## 环形链表



![20220925103433](%E6%95%B0%E7%BB%84%E9%93%BE%E8%A1%A8/20220925103433.png)


$$
slow = x+y \\
fast = x+y+n(y+z) \\
fast = 2*slow
$$
 计算得到
$$
x = (n-1)(y+z)+z
$$
代表，**从头节点走向环形入口  = 从相遇点出发走n个节点**

> 意味着： 从相遇点触发  一定会遇到从头节点触发的节点
>
> 相遇节点 为 环进入节点

## 交换链表

### 交换相邻连个元素链表

[交换两个元素](https://programmercarl.com/0024.两两交换链表中的节点.html#思路)

> 链表中，没有头指针，增加一个虚拟头指针dummyhead

1. 获得cur->next, 因断链，保存cur->next
2. 获得cur->next->next,  因断链，保存cur->next->next->next
3. 获得cur->next->next->next

<img src="%E6%95%B0%E7%BB%84%E9%93%BE%E8%A1%A8/image-20250917200804409.png" alt="image-20250917200804409" style="zoom:80%;" />

### 反转链表

[回文链表](https://programmercarl.com/0234.回文链表.html#思路)

1. 使用快慢指针，找到链表中间节点

   >slow 与 fast 同时指向 head 节点开始
   >
   >1. 偶数链表， slow节点在中间靠后节点
   >
   ><img src="%E6%95%B0%E7%BB%84%E9%93%BE%E8%A1%A8/image-20250917212330639.png" alt="image-20250917212330639" style="zoom:80%;" />
   >
   >2. 奇数链表，slow节点在中间节点
   >
   >   <img src="%E6%95%B0%E7%BB%84%E9%93%BE%E8%A1%A8/image-20250917212525497.png" alt="image-20250917212525497" style="zoom:80%;" />
   >
   >

2. 后半段链表翻转

   >1. 需使用pre节点存放前一节点
   >2. 断开链表后，需要存放后一节点
   >
   ><img src="%E6%95%B0%E7%BB%84%E9%93%BE%E8%A1%A8/image-20250917213101697.png" alt="image-20250917213101697" style="zoom:80%;" />

3. 前后两端比较，不同则返回错误

## 前缀和

将之间计算的结果累加保存在数据中，之后使用时使用结算完成的数组

**需要更具题目要求，选择计算什么样的前缀数组**

```cpp
 while (~scanf("%d%d", &a, &b))//按位取反，如果结果是eof=-1,取反之后结果为0
```



# 双指针

## 双指针指向头尾

[有效的山脉数量](https://programmercarl.com/1207.独一无二的出现次数.html#思路)

1. `left ` 与 `right`分别从前后遍历
2. 如果二者相遇，则是有效的山脉

## 移出元素

[移出0](https://programmercarl.com/0283.移动零.html#思路)

1. slow 指向新的指针
2. fast 指向旧的指针
3. 将旧指针的元素放在新指针的位置

## 右移元素

[右移数组元素](https://programmercarl.com/0189.旋转数组.html#思路)

依旧可以使用[移动元素](#移出元素) 的思想

1. slow 指向 新的指针
2. fast 指向旧的指针

> 需要注意：
>
> 1. 移动数据，会对数据进行覆盖，应复制一个元素
> 2. fast指针不能越界，需进行 `fast = (fast+1) % nums.size()`

## 左右元素相同

1. left, right 分别代替`i`左右元素之和
2. `right = sum - left - num[i]`

## 排除重复元素

[长键盘按入](https://programmercarl.com/0925.长按键入.html#思路)

> 情况较多，需列出可能的情况

比较name[i] 与 `type[j]` 由两种情况

1. 相同，则`i, j` 同时向后移动

2. 不相同， `j`与 `i-1`比较，相同，则`j`向后移动

   > 因为 i = 0 时，不能向前比较，如果结果不同，直接返回错误

比较完成后，`name `与 `typed`有可能有剩余

1. name有剩余 《=》 `i< name.size()`
2. typed有剩余， typed需要与`name[end]` 作比较































# 感谢

[代码随想录](https://programmercarl.com/)

