---
title: 栈-队列
date: 
tags: [leetcode, 代码随想录,编程]
categories:
- 编程
hide: false
---

# 栈	

**感谢[代码随想录](https://programmercarl.com/0101.对称二叉树.html#思路)**

## 栈模拟队列

[模拟队列](https://programmercarl.com/0232.用栈实现队列.html#算法公开课)

![232.用栈实现队列版本2](https://file1.kamacoder.com/i/algo/232.%E7%94%A8%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97%E7%89%88%E6%9C%AC2.gif)

使用两个栈模拟队列

1. 入队时， 直接入队
2. 出队时， 将输入栈的数据放入输出栈中，将顺序倒置为先入先出
3. 判空时，需要判断两个栈是否为空

## 栈队列排除元素

[含有退格的字符串](https://programmercarl.com/0844.比较含退格的字符串.html#思路)

> 题目中遇到`i`元素， 需要退回`i-1`的元素时，可以使用栈弹出`i-1`元素

### 双指针法

slow , fast 从后向前比较

1. 元素相同，同时向前
2. 遇到`#` ，slow / fast 向前
3. 否则， 返回false

# 队列

## 队列模拟栈

![225.用队列实现栈](%E6%A0%88-%E9%98%9F%E5%88%97/225.%E7%94%A8%E9%98%9F%E5%88%97%E5%AE%9E%E7%8E%B0%E6%A0%88.gif)

可以使用一个队列实现栈的模拟

1. 入栈时，直接入队
2. 出栈时，需要将前置数据依次排出，并放置在队首，**出队时需要保留最后一个元素出队**

## 滑动窗口最大值

[滑动窗口最大值](https://programmercarl.com/0347.前K个高频元素.html#思路)

`deque` 用法

```c++
#include <deque>
deque<int> d;
d.front(), d.back();
d.push_back(), d.pop_back();
d.push_front(), d.pop_front();
```

构建排序队列，将可能的最大值放入队列中，定义新的队列弹出方法

1. 入队，入队值如果大于栈顶值，将栈顶出栈，直到入队值小于栈顶值
2. 出队，队首值如果等于移除的数据，将输出出栈
3. 保持第一个值是最大值a，且比a小的值是在a之后入栈的，所以出队时a之前的数据已经弹出完毕

## 优先队列

[前k个高频词汇](https://programmercarl.com/0347.前K个高频元素.html#思路)

`priority_queue`需要自定义排序类型

1. 使用` bool operator()(const int& a, const int& b)自定义比较类型
2. 快排中left> right，从大到小，优先队列反过来

```c++
class mycomparison{
    public:
    bool operator()(const pair<int, int>& a, const pair<int, int>& b){
        return a.second > b.second;
    }
};
priority_queue< pair<int, int>, vector<pair<int, int>> , mycomparison> q;

```

使用小顶堆，优先排除较小元素，将较大元素保留在优先队列中。

# 单调栈

## 右侧最高气温

[最高气温](https://programmercarl.com/0739.每日温度.html)

查找右边 比 当前元素更小的元素

1. 右边比自身大，找到了，当前元素出栈
2. 右边比自身小，没找到，入栈

栈中元素为待查找的元素，找到了就出栈

## nums1元素在nums2中下一个最大元素

[nums1元素在nums2中下一个最大元素](https://programmercarl.com/0496.下一个更大元素I.html)

1. 先计算`num2`中下一个更大元素的结果，保存在`map`中
2. `num1`从`map`中取得结果

## 循环数组的下一最大元素

[循环数组的下一最大元素](https://programmercarl.com/0503.下一个更大元素II.html#算法公开课)

`nums`是一个循环数组，最后一个元素接在第一个元素

> 1. 对数组循环时， 使用 **`% nums.size()`** 对数组循环遍历
> 2. 遍历次数增加一倍，从`1 `遍历到 `2*n`

## 接雨水

[接雨水](https://programmercarl.com/0042.接雨水.html#思路)

左边和右边高度高于中间时，中间出现凹槽， 可以接到雨水

### 暴力求解 

当前节点`j`

1. 左边`[0,j-1]`最大高度`lheight `,右边`[j+1 , end]`最大高度`rheight`，每次暴力求解这两个指针

2. 计算高度差，使用列方向计算求和

   <img src="%E6%A0%88-%E9%98%9F%E5%88%97/20210402091208445.png" alt="列方向求和" style="zoom:75%;" />

### 动态规划

1. `j`左边最大高度 = `j-1`左边最高高度，或者`height[j-1]`
2. 右边计算公式为 `rheight[j] =  max(rheight[j+1] , height[j+1])`

先计算出`dp`， 代替[暴力求解](#暴力求解) 中的双指针

### 单调栈

单调递增栈中，栈底 > 栈头

如果出栈`j`， 栈头元素> `j`, 即将入栈元素 > `j`， 出现凹槽，计算这个凹槽

宽 = `入栈元素 - 栈顶元素`， 高度 = `min(入栈， 栈顶) - 出栈元素(凹槽)`

![行计算](%E6%A0%88-%E9%98%9F%E5%88%97/20210223092629946.png)
